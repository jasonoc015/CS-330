# CS-330

## Approach
This project reinforced the emphasis on modularizing your code. The shape primitives that we created for this project became quite large, especially for the sphere and cylinder. Creating functions to abstract away the object creation made the code much cleaner and reuseable.
The design process I used was start small, then work your way up. I began with creating all of the shape primitives that I needed for the scene. I added translations, rotations and scaling. Then I moved on to textures. I selected an individual texture that accurately represented each object. Lastly, I moved onto lighting. I used different lights to accurately represent the scene as it would be lit in its real-world counterpart.
I believe this type of process can be used in professional development. Starting small is a good way to establish core functionality without worrying about all the bells and whistles. When you focus on the core elements, you can create a strong foundation to which you can add on additional features later. Not to mention, if you started small and decided you need to start over, you can do so with ease.


## Development
I don't think I used any new development strategies here. I did however use strategies that I am well versed in. For example, abstracting the object mesh creation to specific functions.
Iteration was used heavily. As I described above, the entire process was iterating on previous successes. Inside of each step comes its own element of guess and check, particularly when it came to lighting. For a lot of the values, it's hard to know exactly what the values will produce in the scene until you run the code. This makes the process of development entirely iterative.
I learned that having fundamental objects at your disposal makes development mush more simplified. Trying to mesh the entire scene in one VAO would take a ridiculous amount of time and likely not work due to human error. Breaking down the scene into primitive objects makes for a much easier experience.

## The Future
I don't have a whole lot of desire to pursue computer graphics specifically. However, I do think that these concepts are fundamental to computer science. Doing work in any field will most likely use computer graphics or use some of the concepts here. Without a crystal ball, it's hard to say for certain but I do anticipate this level of software design and development to be continued throughout any computer sceince pathway.
I believe that computer graphics shows you that trying to swallow a project whole on the first go is a naive pursuit. Instead, breaking down the project into smaller parts, or primitives, and then building the grand scheme with those smaller parts in a methodical way. This approach leads to cleaner, more readable, and reuseable software.
